# 软件产品知识库（Knowledge Graph System）设计文档

## 1. 概述

本知识库系统（KGS）是一个软件级基础设施，旨在为"无状态 AI
开发模式"提供结构化、可编排、可验证的软件知识。其作用是作为整个软件产品的"可信记忆层"和"统一事实源（SSOT）"，管理软件所有的功能、依赖、设计文档、测试案例以及代码关联信息。

## 2. 设计目标

-   **最小化认知负荷**：为每次无上下文的 AI
    调用提供精准、最小却充分的上下文。
-   **强一致性**：先文档、后代码，所有变更必须在知识库过审。
-   **可组合性与可扩展性**：支持随着软件规模增长而保持可管理。
-   **可验证性**：结构化记录每次开发任务、变更、状态、证明材料。

## 3. 核心架构

### 3.1 逻辑分层

1.  **概念层（Concept Layer）**
    -   软件产品的核心领域模型
    -   产品功能点、模块、业务对象、实体定义
    -   产品心智模型（Mental Model）
2.  **项目分解层（Project Decomposition Layer）**
    -   项目 → 子项目 → 任务
    -   具备 DAG（有向无环图）依赖结构
    -   强制粒度控制：功能级 + 任务级
3.  **文档层（Documentation Layer）**
    -   PRD（功能需求文档）
    -   设计文档（技术、架构）
    -   测试文档（用例 + 断言）
    -   关联：功能 → 文档 → 代码
4.  **代码层（Code Layer）**
    -   文件、函数、端点、数据库表结构
    -   代码片段的结构解析（AST）以自动建立映射
5.  **验证层（Verification Layer）**
    -   文档 → 代码 Diff 验证
    -   测试用例是否覆盖功能
    -   任务是否达到最小工作量门槛
6.  **API 层（AI Runtime Layer）**
    -   AI 查询接口
    -   AI 变更申请接口（非直接写入）
    -   AI 审核、证明文档接口

------------------------------------------------------------------------

## 4. 数据模型（Data Schema）

### 4.1 核心实体

#### **Feature（功能点）**

-   id
-   title
-   description
-   parent_feature_id
-   dependencies(feature_id list)
-   maturity_level (draft, reviewed, implemented, verified)
-   linked_docs
-   linked_code_units
-   linked_tests

#### **Doc（文档）**

-   id
-   type (prd/design/test)
-   content
-   version
-   related_feature_id
-   checksum

#### **CodeUnit（代码单元）**

-   id
-   type (file/function/api/db schema)
-   path
-   signature
-   summary（自动生成）
-   checksum
-   related_feature_id

#### **TestCase（测试用例）**

-   id
-   title
-   steps
-   assertions
-   related_feature_id
-   related_code_id

#### **Task（AI 执行任务）**

-   id
-   input_context
-   output_artifacts
-   required_workload
-   status
-   proof（工作量证明）

------------------------------------------------------------------------

## 5. 知识图谱 API

### 5.1 只允许结构化变更

AI 不能直接修改内容，但可以通过以下 API 申请变更：

-   `kg.create_feature()`
-   `kg.update_feature_metadata()`
-   `kg.attach_doc()`
-   `kg.attach_code_unit()`
-   `kg.validate_consistency()`
-   `kg.prove_task_workload()`
-   `kg.graph_export()`

所有变动都必须通过三阶段提交： 1. AI 提交变更 proposal 2.
系统验证结构完整性 3. 系统自动更新知识图谱并生成变更日志

------------------------------------------------------------------------

## 6. 粒度控制机制

### 6.1 粒度规范

-   Feature 粒度 = **用户可感知的功能点**
-   Code 粒度 = **可独立测试的单元**
-   测试粒度 = **至少验证一个用户价值点**

### 6.2 防止知识图谱爆炸

-   自动聚类（AST + embedding）
-   自动去重
-   "冷数据归档"
-   使用图数据库（Neo4j 或 Dgraph）

------------------------------------------------------------------------

## 7. 无状态 AI 开发工作流

### 步骤

1.  **选择任务**（必须满足最小工作量）
2.  **KGS 生成上下文包（Context Package）**
3.  **AI 完成任务并输出：文档+代码+证明材料**
4.  **先文档审查**
5.  **代码审查与文档一致性校验**
6.  **KGS 自动更新图谱**

### 上下文包内容

-   当前任务关联的 Feature
-   所有依赖 Feature
-   关联文档摘要
-   关联代码摘要（非全文）
-   关联测试用例摘要
-   运行时约束（如负熵规则）

------------------------------------------------------------------------

## 8. 最小工作量约束（Proof-of-Workload）

任务必须包含： - 至少一个有效 Feature 修改 - 文档 → 代码 →
测试三链条中至少两链条的产出 - 不允许 trivial 工作（例如 UI 字段替换）

PoW 示例： - 新增一个后端 API + PRD + 测试 - 重写模块架构文档 +
完成代码重构 - 实现一个完整 feature 的前后端环节

------------------------------------------------------------------------

## 9. 系统难点与解决方案

### 难点 1：知识图谱一致性维护

**解决：**三阶段提交 + 自动静态分析 + 文档-代码一致性检验

### 难点 2：自动化代码结构解析

**解决：**AST 解析器 + embedding 语义聚类 + LLM summarizer

### 难点 3：文档与代码的双向链接

**解决：**\
- 代码注解自动读入\
- 文档内的引用自动被解析为结构化节点

### 难点 4：无状态 AI 的上下文构建

**解决：**\
- Context Package Template\
- 按需压缩与摘要

### 难点 5：开发者体验（DX）

**解决：**\
- 统一 CLI 工具\
- 自动变更日志\
- 实时图谱可视化

------------------------------------------------------------------------

## 10. 未来扩展方向

-   自动生成 Feature Roadmap
-   多 AI 协作模式
-   自动生成架构图（Mermaid / Draw.io）
-   自动生成回归测试集
-   支持多编程语言

------------------------------------------------------------------------

## 11. 结论

本知识库系统是整个"AI 无状态开发规范"的核心基础设施。\
虽然开发难度高，但技术上完全可行，且一旦落地，将成为"下一代软件工程"的关键框架。\
它既是工具，也是规范，更是软件产品的数字孪生大脑。
