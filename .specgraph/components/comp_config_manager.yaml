# Component Definition: Config Manager
# Implements: feat_config_management

id: comp_config_manager
type: module
desc: "Configuration loading, merging, and access with layered overrides."
file_path: "devspec/infra/config.py"

tech_stack:
  - "PyYAML"
  - "os.environ (for environment variable access only, NOT os.path)"
  - "pathlib (Strictly NO os.path per STRICT TECH STACK)"
  - "Manual .env parsing (NOT using python-dotenv to avoid extra dependency)"

dependencies: []

design:
  api:
    - signature: "def get_config(key: str, default: Any = None) -> Any"
      desc: "Get a configuration value by key with optional default (Public API)."
      params:
        - name: "key"
          type: "str"
          desc: "Config key, supports dot notation (e.g., 'database.path')"
        - name: "default"
          type: "Any"
          desc: "Default value if key not found"
      returns:
        type: "Any"
        desc: "Config value or default"

    - signature: "def load_config(path: Path) -> Dict"
      desc: "Load configuration from a YAML file (Public API)."
      params:
        - name: "path"
          type: "Path"
          desc: "Path to config file"
      returns:
        type: "Dict"
        desc: "Loaded configuration dictionary"

    - signature: "def load_env_file(path: Path = Path('.env')) -> None"
      desc: "Load environment variables from .env file (Public API)."
      params:
        - name: "path"
          type: "Path"
          desc: "Path to .env file (default: project root .env)"
      returns:
        type: "None"
        desc: "No return value, updates os.environ"

    - signature: "def get_debug_mode(cli_flag: Optional[bool] = None) -> bool"
      desc: "Get debug mode setting with priority: CLI > .env > default (Public API)."
      params:
        - name: "cli_flag"
          type: "Optional[bool]"
          desc: "CLI --debug flag value (None if not provided)"
      returns:
        type: "bool"
        desc: "True if debug mode enabled"

    - signature: "def _init_config() -> Dict"
      desc: "Initialize and return merged config dictionary (Internal helper, called once per process)."
      returns:
        type: "Dict"
        desc: "Merged configuration dictionary"

  logic: |
    模块级变量 (CLI 工具无需 Singleton 或 reload，进程生命周期内配置不变):
    - _config: Dict = None  # 模块级缓存，延迟初始化

    1. _init_config() -> Dict:
       1.1 复制 DEFAULT_CONFIG 作为基础配置 (步骤 1: 默认值)
       1.2 尝试加载 .specgraph/config.yaml (如果存在) (步骤 2: YAML 配置文件)
           - 使用 load_config() 读取文件
           - 使用 _deep_merge(config, loaded_yaml) 合并到基础配置
       1.3 调用 load_env_file() 加载 .env 文件 (如果存在) (步骤 3: .env 文件)
           注意: .env 文件内容会更新到 os.environ，在步骤 1.4 统一处理
       1.4 调用 _apply_env_overrides(config) 应用系统环境变量 (步骤 4: DEVSPEC_* 系统环境变量)
           注意: 包括 .env 文件中的 DEVSPEC_* 变量 (已加载到 os.environ)
       1.5 返回合并后的配置字典

    2. get_config(key, default):
       2.1 如果 _config is None: _config = _init_config() (懒加载，仅首次调用时初始化)
       2.2 按 '.' 分割 key
       2.3 逐层访问 _config
       2.4 如果任意层不存在，返回 default
       2.5 返回找到的值

    3. load_config(path):
       3.1 读取文件内容 (path.read_text(encoding='utf-8'))
       3.2 yaml.safe_load(content)
       3.3 返回 dict

    4. load_env_file(path):
       4.1 检查 .env 文件是否存在
       4.2 手动解析 .env 文件 (不使用 python-dotenv):
           - 逐行读取文件内容
           - 跳过空行和以 # 开头的注释行
           - 解析 KEY=VALUE 格式 (支持引号: "value", 'value')
           - 处理转义字符 (\n, \t, \\, \")
       4.3 更新 os.environ
       4.4 日志记录加载结果 (debug level)

    5. get_debug_mode(cli_flag):
       5.1 如果 cli_flag is not None: 返回 cli_flag (CLI 优先级最高)
       5.2 读取环境变量 DEBUG 或 DEVSPEC_DEBUG (来自 .env 或系统环境变量)
       5.3 将字符串转换为 boolean:
           - 如果 env_value.lower() in ("true", "1", "yes"): 返回 True
           - 如果 env_value.lower() in ("false", "0", "no"): 返回 False
       5.4 否则返回 False (默认值，对应 constants 中的 debug: false)

    6. _apply_env_overrides(config: Dict) -> None (内部辅助函数):
       6.1 遍历所有 DEVSPEC_ 前缀的环境变量
       6.2 将 DEVSPEC_DATABASE_PATH 转换为 database.path (下划线转点号)
       6.3 使用 _set_nested() 覆盖 config 中对应的值

    7. _deep_merge(base: Dict, override: Dict) -> Dict (内部辅助函数):
       7.1 如果都是 dict，递归合并所有键
       7.2 否则 override 覆盖 base
       7.3 返回合并结果

    8. _set_nested(config: Dict, key: str, value: Any) -> None (内部辅助函数):
       8.1 按 '.' 分割 key
       8.2 逐层创建/访问 config
       8.3 设置最终值

  constants:
    DEFAULT_CONFIG:
      database:
        path: ".specgraph/.runtime/specgraph.db"
      logging:
        level: "INFO"  # Valid values: DEBUG, INFO, WARNING, ERROR, CRITICAL
        format: "rich"
      spec:
        root: ".specgraph"
      debug: false  # Default debug mode (boolean), env vars will be converted from string
    ENV_PREFIX: "DEVSPEC_"
    CONFIG_FILE_NAME: "config.yaml"
    ENV_FILE_NAME: ".env"
    DEBUG_ENV_KEYS: ["DEBUG", "DEVSPEC_DEBUG"]  # Accepted env var names for debug mode
    DEBUG_TRUE_VALUES: ["true", "1", "yes"]  # String values that map to boolean True
    DEBUG_FALSE_VALUES: ["false", "0", "no"]  # String values that map to boolean False

  error_handling:
    - condition: "Config file not found"
      action: "Log debug, use defaults only"
    - condition: "Invalid YAML syntax"
      action: "Log error, skip file, use previous config"
    - condition: "Invalid key format"
      action: "Log warning, return default"
    - condition: ".env file not found"
      action: "Silently continue (optional file), use defaults"
    - condition: "Invalid .env file format"
      action: "Log warning, skip malformed lines, continue with valid lines"

  notes: |
    Design Rationale (CLI Tool Specifics):
    - Simple Module-Level Design: No Singleton pattern, no ConfigManager class, no reload() method.
      DevSpec is a CLI tool where each command runs as an independent process (devspec monitor, devspec sync).
      Config is loaded once at process startup and never changes during the process lifetime.
      This eliminates the need for hot-reload, file watching, or complex state management.

    - Lazy Initialization: Module-level _config is None by default, initialized on first get_config() call.
      This avoids unnecessary file I/O if a command doesn't need configuration.

    - Namespace Isolation: Achieved implicitly through dot-notation keys (e.g., "database.path", "logging.level").
      No explicit Namespace class. The hierarchical structure in DEFAULT_CONFIG serves as namespace boundaries.
      Example: All database-related configs are under "database.*", all logging configs under "logging.*".

    - Public vs Internal APIs:
      Public APIs (exported by dom_infra): get_config(), load_config(), load_env_file(), get_debug_mode()
      Internal helpers: _init_config(), _apply_env_overrides(), _deep_merge(), _set_nested()

    - .env File Processing Flow (Unified Handling via os.environ):
      load_env_file() loads .env file and updates os.environ (e.g., DEBUG=true, DEVSPEC_DATABASE_PATH=xxx).
      Then _apply_env_overrides() processes ALL os.environ variables (including those from .env and system env).
      This design ensures .env variables are handled consistently with system environment variables.
      Example: .env contains "DEVSPEC_DATABASE_PATH=/custom/path" → updates os.environ →
               _apply_env_overrides() converts it to config["database"]["path"] = "/custom/path"

    - Config Validation: Basic type checking only, no schema validation. Assume config values are correct.
