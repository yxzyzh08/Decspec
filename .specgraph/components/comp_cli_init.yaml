# Component Definition: Init Command
# Part of feat_cli_command_structure
# Validated against sub_meta_schema.yaml

id: comp_cli_init
type: module
desc: "`devspec init` 命令实现，为 Claude Code 和 Gemini CLI 生成 slash command 文件（包括 devspec-monitor 和 devspec-write-prd），使 AI CLI 可直接调用 DevSpec 命令。"
file_path: "devspec/commands/init.py"

tech_stack:
  - typer
  - rich
  - pathlib

dependencies:
  - comp_cli_app

# === 详细设计 (Design) ===
design:
  # 公开接口定义
  api:
    - signature: "def init() -> None"
      desc: "生成 AI CLI 的 slash command 文件"
      params: []
      returns:
        type: "None"
        desc: "无返回值，通过 side effect 生成文件"

  # 伪代码逻辑
  logic: |
    1. 初始化 Rich console 对象
    2. 定义模板常量:
       - CLAUDE_MONITOR_TEMPLATE: Claude Code 的 devspec-monitor 模板 (Markdown)
       - GEMINI_MONITOR_TEMPLATE: Gemini CLI 的 devspec-monitor 模板 (TOML)
       - CLAUDE_COLLECT_REQ_TEMPLATE: Claude Code 的 devspec-collect-req 模板 (Markdown)
       - GEMINI_COLLECT_REQ_TEMPLATE: Gemini CLI 的 devspec-collect-req 模板 (TOML)
    3. 定义 commands 列表，每项包含 {path, content, cli_name}:
       - .claude/commands/devspec-monitor.md
       - .gemini/commands/devspec-monitor.toml
       - .claude/commands/devspec-collect-req.md
       - .gemini/commands/devspec-collect-req.toml
    4. 打印开始信息 "DevSpec Init: Generating AI CLI slash commands..."
    5. 遍历 commands 列表:
       5.1 检查文件是否存在 (Path.exists())
           - 如果存在: 打印跳过信息 "⚠ {cli_name}: {path} already exists, skipping." 并继续下一项
       5.2 创建父目录 (Path.mkdir(parents=True, exist_ok=True))
       5.3 写入模板内容 (Path.write_text, encoding=utf-8)
       5.4 打印成功信息 "✓ {cli_name}: {path}"
    6. 打印使用说明:
       - Claude Code: /devspec-monitor, /devspec-collect-req
       - Gemini CLI: /devspec-monitor, /devspec-collect-req

  # 关键常量
  constants:
    CLAUDE_MONITOR_TEMPLATE: |
      ---
      allowed-tools: Bash(uv run devspec monitor:*)
      description: Run DevSpec consistency monitor and generate dashboard
      ---
      # DevSpec Monitor

      Run the consistency check to verify alignment between PRD (Markdown) and SpecGraph (YAML).

      **Usage**
      ! uv run devspec monitor $ARGUMENTS

    GEMINI_MONITOR_TEMPLATE: |
      description = "Run DevSpec consistency monitor and generate dashboard"
      prompt = """
      Run the DevSpec consistency monitor to check alignment between PRD and SpecGraph.
      Command: `uv run devspec monitor`
      """

    CLAUDE_COLLECT_REQ_TEMPLATE: |
      ---
      allowed-tools: Read, Bash(uv run devspec context:*), Bash(uv run devspec monitor:*)
      description: Collect, analyze and decompose user requirements
      ---
      # DevSpec Requirement Collector

      You are the **DevSpec Requirement Collector**. Follow the 4-Phase dialogue flow to understand and decompose user requirements.

      **Core Principle**: 理解优先于分解，对话优先于流程 (Understanding before decomposition, dialogue before pipeline)

      ---

      ## Phase 1: Understanding (理解需求) - REQUIRES CONFIRMATION

      1. Load Product Vision:
         ! uv run devspec context understanding

      2. Read the context output, then **restate the user's requirement in your own words**.

      3. Ask the user: "我理解您的需求是 XXX，这个理解正确吗？"

      4. **STOP and wait for user confirmation before proceeding.**

      ---

      ## Phase 2: Locating (定位影响)

      After user confirms understanding:

      1. Based on the product.yaml already loaded in Phase 1 (contains domains), identify which Domain(s) are affected.

      2. If cross-domain impact, explain the dependencies.

      3. Load Features for affected Domain(s):
         ! uv run devspec context locating --domain <domain_id>

      4. Determine if this is:
         - A new Feature (requires Exhaustiveness Check)
         - Modification to existing Feature
         - Code-only change (skip Spec updates)

      ---

      ## Phase 3: Evaluating (评估变更)

      1. If modifying existing Feature, load Feature context:
         ! uv run devspec context evaluating --focus <feature_id>

      2. **Exhaustiveness Check** (CRITICAL):
         - List all existing Features/Components in the affected area
         - For EACH one, evaluate: "Can this requirement be satisfied by modifying this node?"
         - Record rejection reason for each
         - Only create NEW nodes if ALL existing nodes cannot satisfy

      3. If new Feature needed:
         - Check Vision alignment
         - If not aligned, ask user: "此需求超出当前 Vision，是否要扩展？"

      ---

      ## Phase 4: Planning (生成计划) - REQUIRES CONFIRMATION

      1. Load dependency graph:
         ! uv run devspec context planning --focus <node_id>

      2. Generate change lists:
         - Spec changes (PRD.md, YAML files)
         - Code changes (Python files)
         - Execution order (based on dependencies)

      3. Present plan to user and ask: "是否按此计划执行？"

      4. **STOP and wait for user confirmation before executing.**

      ---

      ## User Requirement

      $ARGUMENTS

    GEMINI_COLLECT_REQ_TEMPLATE: |
      description = "Collect, analyze and decompose user requirements"
      prompt = """
      You are the **DevSpec Requirement Collector**. Follow the 4-Phase dialogue flow to understand and decompose user requirements.

      **Core Principle**: 理解优先于分解，对话优先于流程 (Understanding before decomposition, dialogue before pipeline)

      ---

      ## Phase 1: Understanding (理解需求) - REQUIRES CONFIRMATION

      1. Load Product Vision by running: `uv run devspec context understanding`

      2. Read the context output, then **restate the user's requirement in your own words**.

      3. Ask the user: "我理解您的需求是 XXX，这个理解正确吗？"

      4. **STOP and wait for user confirmation before proceeding.**

      ---

      ## Phase 2: Locating (定位影响)

      After user confirms understanding:

      1. Based on the product.yaml already loaded in Phase 1 (contains domains), identify which Domain(s) are affected.

      2. If cross-domain impact, explain the dependencies.

      3. Load Features for affected Domain(s) by running: `uv run devspec context locating --domain <domain_id>`

      4. Determine if this is:
         - A new Feature (requires Exhaustiveness Check)
         - Modification to existing Feature
         - Code-only change (skip Spec updates)

      ---

      ## Phase 3: Evaluating (评估变更)

      1. If modifying existing Feature, load Feature context:
         `uv run devspec context evaluating --focus <feature_id>`

      2. **Exhaustiveness Check** (CRITICAL):
         - List all existing Features/Components in the affected area
         - For EACH one, evaluate: "Can this requirement be satisfied by modifying this node?"
         - Record rejection reason for each
         - Only create NEW nodes if ALL existing nodes cannot satisfy

      3. If new Feature needed:
         - Check Vision alignment
         - If not aligned, ask user: "此需求超出当前 Vision，是否要扩展？"

      ---

      ## Phase 4: Planning (生成计划) - REQUIRES CONFIRMATION

      1. Load dependency graph:
         `uv run devspec context planning --focus <node_id>`

      2. Generate change lists:
         - Spec changes (PRD.md, YAML files)
         - Code changes (Python files)
         - Execution order (based on dependencies)

      3. Present plan to user and ask: "是否按此计划执行？"

      4. **STOP and wait for user confirmation before executing.**

      ---

      ## User Requirement

      {{arguments}}
      """

  # 输出文件格式
  output_files:
    - path: ".claude/commands/devspec-monitor.md"
      format: "Markdown with YAML frontmatter"
      encoding: "utf-8"
    - path: ".gemini/commands/devspec-monitor.toml"
      format: "TOML with description and prompt"
      encoding: "utf-8"
    - path: ".claude/commands/devspec-collect-req.md"
      format: "Markdown with YAML frontmatter"
      encoding: "utf-8"
    - path: ".gemini/commands/devspec-collect-req.toml"
      format: "TOML with description and prompt"
      encoding: "utf-8"
