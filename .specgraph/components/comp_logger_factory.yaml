# Component Definition: Logger Factory
# Implements: feat_logging

id: comp_logger_factory
type: module
desc: "Logger creation and configuration, managing logger instance pool."
file_path: "devspec/infra/logger.py"

tech_stack:
  - "logging (stdlib)"
  - "Rich"

dependencies: []

design:
  api:
    - signature: "def get_logger(name: str) -> Logger"
      desc: "Get or create a named logger instance (Public API, exported by dom_infra)."
      params:
        - name: "name"
          type: "str"
          desc: "Logger name, typically module path (e.g., 'devspec.core.sync')"
      returns:
        type: "Logger"
        desc: "Configured logger instance"

    - signature: "def configure_logging(level: str = 'INFO', format: str = 'rich', log_file: Optional[Path] = None) -> None"
      desc: "Configure global logging settings. Called once at CLI entry point (Public API, exported by dom_infra)."
      params:
        - name: "level"
          type: "str"
          desc: "Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)"
        - name: "format"
          type: "str"
          desc: "Output format: 'rich' (console with colors), 'plain' (simple)"
        - name: "log_file"
          type: "Optional[Path]"
          desc: "Optional file path for log output"

  logic: |
    模块级变量 (CLI 工具简化设计，无需 Singleton 或类):
    - _loggers: Dict[str, Logger] = {}  # Logger 缓存
    - _configured: bool = False  # 是否已配置全局日志

    1. configure_logging(level, format, log_file):
       1.1 如果 _configured: 直接返回 (防止重复配置)
       1.2 获取 root logger (logging.getLogger())
       1.3 清除 root logger 的所有现有 handlers (避免重复)
       1.4 设置 level: root_logger.setLevel(level)
       1.5 根据 format 创建并添加 handler:
           - 'rich': 使用 rich.logging.RichHandler
                     配置: show_time=True, show_path=True, markup=True
           - 'plain': 使用 logging.StreamHandler
                      配置: formatter with DEFAULT_FORMAT
       1.6 如果指定 log_file:
           1.6.1 创建 log_file 的父目录 (Path.mkdir(parents=True, exist_ok=True))
           1.6.2 创建 FileHandler (mode='a', encoding='utf-8')
           1.6.3 设置 formatter (DEFAULT_FORMAT)
           1.6.4 添加到 root logger
       1.7 设置 _configured = True

    2. get_logger(name):
       2.1 如果 name 在 _loggers 中: 返回缓存的 logger
       2.2 否则:
           2.2.1 创建 logger = logging.getLogger(name)
           2.2.2 logger 自动继承 root logger 的配置 (handlers, level)
           2.2.3 缓存到 _loggers[name]
           2.2.4 返回 logger

  constants:
    DEFAULT_FORMAT: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    LOG_LEVELS:
      - "DEBUG"
      - "INFO"
      - "WARNING"
      - "ERROR"
      - "CRITICAL"
    DEFAULT_LEVEL: "INFO"
    DEFAULT_FORMAT_TYPE: "rich"

  error_handling:
    - condition: "Invalid log level"
      action: "Log warning to stderr, use INFO as default"
    - condition: "Log file not writable"
      action: "Log warning to stderr, skip file handler, continue with console logging"
    - condition: "Rich library not available"
      action: "Fall back to plain format with StreamHandler"

  notes: |
    Design Rationale (CLI Tool Specifics):
    - Simple Module-Level Design: No Singleton pattern, no LoggerFactory class, no set_level() method.
      DevSpec is a CLI tool where each command runs as an independent process.
      Logging configuration is set once at process startup (in main.py) and never changes.
      This eliminates the need for runtime level adjustment or complex factory patterns.

    - Module-Level Caching: Use _loggers dict to cache logger instances by name.
      This avoids creating duplicate loggers for the same module.

    - Global Configuration: configure_logging() is called once at CLI entry point (main.py).
      It configures the root logger, and all child loggers inherit the configuration automatically.

    - Public vs Internal:
      Public APIs (exported by dom_infra): get_logger(), configure_logging()
      No internal helpers needed (logic is simple enough to inline)
