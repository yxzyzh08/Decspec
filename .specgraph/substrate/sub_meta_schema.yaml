# Meta-Schema Definition for DevSpec
# This file defines the structure, granularity, and validation rules for all SpecGraph nodes.
# It serves as the "Constitution" for the Knowledge Graph.

id: sub_meta_schema
type: substrate
name: "Meta-Schema Definition"
description: "Defines the schema, granularity, and validation rules for product, feature, component, design, and substrate nodes."
source_anchor: "PRD.md#sub_meta_schema"

# ============================================================
# 知识分类 (Knowledge Classification)
# ============================================================
# SpecGraph 中的知识分为两类：Design 和 Substrate
#
# Design (设计) - Why & What:
#   - 回答"为什么这样设计？目标是什么？"
#   - AI 加载时机：理解项目背景、做架构决策时
#   - 存储位置：.specgraph/design/
#   - 示例：des_philosophy, des_domain_model, des_architecture
#
# Substrate (基质) - How & Constraints:
#   - 回答"怎么执行？有什么约束？"
#   - AI 加载时机：编写代码、验证规范时
#   - 存储位置：.specgraph/substrate/
#   - 示例：sub_tech_stack, sub_meta_schema, sub_coding_style
# ============================================================

# =============================================================================
# 1. 根节点规范 (Root Node - L-1 Level)
# =============================================================================
# Product 只定义愿景和领域概要，不包含 Feature 列表
product_schema:
  path: ".specgraph/product.yaml"
  naming_convention: "product.yaml"
  purpose: |
    Product 是 SpecGraph 的根节点，定义产品愿景和领域划分。
    用于需求分析流程：
    - Step 2: 判断需求是否符合 Vision (读取 vision/description)
    - Step 3: 分析涉及的 Domain (读取 domains 概要)

  required_fields:
    - field: id
      format: "prod_{name}"
      desc: "产品 ID，如 prod_devspec"
    - field: name
      format: "string"
      desc: "产品名称"
    - field: version
      format: "x.y.z"
      desc: "语义化版本号"
    - field: description
      format: "string"
      desc: "产品简述"
    - field: domains
      format: "list[DomainObject]"
      desc: "领域列表 (L0 概要)"

  optional_fields:
    - field: vision
      format: "multiline string"
      desc: "详细产品愿景 (用于 AI 判断需求是否符合愿景)"

  # Domain 对象结构 (嵌套在 product.yaml 中)
  domain_object_schema:
    required_fields:
      - field: id
        format: "dom_{snake_case_name}"
        desc: "领域 ID"
      - field: name
        format: "string"
        desc: "领域名称"
      - field: description
        format: "string"
        desc: "领域职责描述"
    optional_fields:
      - field: exports
        format: "list[DomainAPIObject]"
        desc: "导出的 API 列表 (跨 Domain 协作接口)"
    # 注意：不包含 features 字段！
    # Domain → Feature 关系通过 Feature YAML 的 domain 字段建立
    forbidden_fields:
      - field: features
        reason: "Feature 列表不应在 Domain 中声明，应由 Feature.domain 字段反向建立关系"

  # Domain API 对象结构
  domain_api_schema:
    required_fields:
      - field: name
        format: "string"
        desc: "API 函数名"
      - field: signature
        format: "string"
        desc: "完整函数签名 (含类型注解)"
    optional_fields:
      - field: description
        format: "string"
        desc: "API 描述"

# =============================================================================
# 2. 功能节点规范 (Feature Node - L1)
# =============================================================================
feature_schema:
  path_pattern: ".specgraph/features/feat_{snake_case_name}.yaml"

  granularity:
    definition: "A unit of user value that can be independently verified."
    too_small: "Change button color, fix typo."
    too_large: "The entire CLI system."
    example_good: "CLI Command Dispatcher, Code Scanner, Context Bubble."

  required_fields:
    - field: id
      format: "feat_{snake_case_name}"
      desc: "Feature ID，必须与文件名一致"
    - field: domain
      format: "dom_{name}"
      desc: "所属 Domain ID，必须在 product.yaml 中已定义"
    - field: source_anchor
      format: "PRD.md#feat_{name}"
      desc: "PRD 中的锚点引用"
    - field: intent
      format: "string"
      desc: "这个 Feature 解决什么问题？(The Why)"

  optional_fields:
    - field: user_stories
      format: "list[string]"
      desc: "用户故事列表，格式: 'As a X, I want Y so that Z.'"
    - field: realized_by
      format: "list[comp_id]"
      desc: "实现此 Feature 的 Component ID 列表"
    - field: depends_on
      format: "list[feat_id]"
      desc: "依赖的其他 Feature ID 列表 (显式依赖)"
    - field: workflow
      format: "list[WorkflowStep] | list[WorkflowPhase]"
      desc: "工作流程，支持简单步骤列表或复杂阶段定义"
    - field: design_principles
      format: "list[PrincipleObject]"
      desc: "设计原则列表"
    - field: key_confirmations
      format: "list[ConfirmationPoint]"
      desc: "关键确认点列表"

  # Workflow 结构定义 (两种形式)
  workflow_simple_schema:
    desc: "简单步骤列表"
    structure:
      - field: step
        format: "int"
        desc: "步骤序号"
      - field: action
        format: "string"
        desc: "动作描述"
      - field: output
        format: "string"
        desc: "输出描述 (可选)"

  workflow_phase_schema:
    desc: "复杂阶段定义 (用于需求分析等复杂流程)"
    structure:
      - field: phase
        format: "int"
        desc: "阶段序号"
      - field: name
        format: "string"
        desc: "阶段名称"
      - field: desc
        format: "string"
        desc: "阶段描述"
      - field: steps
        format: "list[string]"
        desc: "步骤列表"
      - field: confirmation_required
        format: "bool"
        desc: "是否需要用户确认"
      - field: context_loaded
        format: "list[string]"
        desc: "此阶段加载的上下文"
      - field: pre_step
        format: "PreStepObject"
        desc: "前置步骤 (如 Exhaustiveness Check)"
      - field: branches
        format: "list[BranchObject]"
        desc: "分支处理逻辑"
      - field: output
        format: "list[string]"
        desc: "阶段输出"

  # 设计原则对象
  design_principle_schema:
    structure:
      - field: name
        format: "string"
        desc: "原则名称"
      - field: desc
        format: "string"
        desc: "原则描述"

# =============================================================================
# 3. 组件节点规范 (Component Node - L2)
# =============================================================================
# 设计原则：Component 是代码的详细设计，目标是让任意 AI 能还原 90-95% 的代码
component_schema:
  path_pattern: ".specgraph/components/comp_{snake_case_name}.yaml"

  # 3.1 粒度定义
  granularity:
    definition: "A cohesive Python module - either a single .py file or a package directory."
    forms:
      single_file:
        desc: "简单组件 (< 500 行)，使用单个 .py 文件"
        example: "devspec/core/markdown_parser.py"
      package_dir:
        desc: "复杂组件，使用包目录 (含 __init__.py)，内部文件由该 Component 统一管理"
        example: "devspec/core/scanner/"
        note: "file_path 以 / 结尾表示包目录"
    example_good:
      - "devspec/core/markdown_parser.py"
      - "devspec/core/scanner/"
    example_bad: "将整个 devspec/core/ 目录作为一个 Component"

  # 3.2 必填字段
  required_fields:
    - field: id
      format: "comp_{snake_case_name}"
      desc: "Component ID"
    - field: type
      format: "module"
      desc: "固定值，表示这是一个代码模块"
    - field: desc
      format: "string"
      desc: "技术描述"
    - field: file_path
      format: "string"
      desc: "单文件路径 (.py) 或包目录路径 (以 / 结尾)"
    - field: design
      format: "DesignObject"
      desc: "详细设计 (见 design_schema)"

  # 3.3 可选字段
  optional_fields:
    - field: tech_stack
      format: "list[string]"
      desc: "使用的库/工具列表"
    - field: dependencies
      format: "list[comp_id]"
      desc: "依赖的其他 Component ID 列表"

  # 3.4 详细设计规范 (design 字段内部结构)
  design_schema:
    description: |
      design 字段是 Component 的核心，定义代码的详细设计。
      目标：让任意 AI (Claude/Gemini/GPT) 能根据此设计还原 90-95% 的代码。
      原则：止步于伪代码和关键常量，不写具体实现代码。

    fields:
      # 公开接口定义 (必填)
      api:
        desc: "公开函数/类的签名与契约"
        required: true
        structure:
          function_api:
            - field: signature
              format: "string"
              desc: "函数签名，如 'def foo(x: int) -> str'"
            - field: desc
              format: "string"
              desc: "功能描述"
            - field: params
              format: "list[ParamObject]"
              desc: "参数列表 [{name, type, desc}]"
            - field: returns
              format: "ReturnObject"
              desc: "返回值 {type, desc}"
            - field: raises
              format: "list[string]"
              desc: "可能抛出的异常 (可选)"
          class_api:
            - field: signature
              format: "string"
              desc: "类签名，如 'class Foo'"
            - field: desc
              format: "string"
              desc: "类描述"
            - field: fields
              format: "list[FieldObject]"
              desc: "类字段列表 [{name, type, desc}] (用于 dataclass/model)"
            - field: methods
              format: "list[MethodObject]"
              desc: "方法列表 (每个方法结构同 function_api)"

      # 伪代码逻辑 (必填)
      logic:
        desc: "实现逻辑的伪代码描述，用自然语言+编号步骤"
        required: true
        format: "multiline string"
        example: |
          1. 初始化 console 对象
          2. 定义模板常量 CLAUDE_TEMPLATE, GEMINI_TEMPLATE
          3. 遍历 commands 列表:
             3.1 创建父目录 (Path.mkdir)
             3.2 写入模板内容 (Path.write_text)
             3.3 打印成功信息
          4. 打印使用说明

      # 关键常量 (条件必填：如果有常量则必填)
      constants:
        desc: "影响输出结果的关键常量、模板、配置"
        required: "conditional - 如果组件包含重要常量/模板则必填"
        format: "dict[name: value]"
        example:
          TEMPLATE: |
            ---
            description: xxx
            ---
            ! uv run devspec monitor

      # 输出文件格式 (条件必填：如果输出是文件则必填)
      output_files:
        desc: "如果组件生成文件，必须定义文件格式"
        required: "conditional - 如果输出包含文件则必填"
        structure:
          - field: path
            format: "string"
            desc: "文件路径模式"
          - field: format
            format: "string"
            desc: "文件格式描述或完整模板"
          - field: encoding
            format: "string"
            desc: "编码 (默认 utf-8)"

      # 错误处理 (可选)
      error_handling:
        desc: "关键错误场景及处理方式"
        required: false
        structure:
          - field: condition
            format: "string"
            desc: "错误条件"
          - field: action
            format: "string"
            desc: "处理方式"

# =============================================================================
# 4. 设计节点规范 (Design Node)
# =============================================================================
# Design 回答 "Why & What" - 设计决策的原因和目标
design_node_schema:
  path_pattern: ".specgraph/design/des_{snake_case_name}.yaml"
  purpose: |
    Design 节点记录设计决策，帮助 AI 理解项目背景和架构目的。
    AI 在以下场景加载 Design：
    - 理解项目整体背景
    - 做架构级别的决策
    - 设计新的 Feature

  required_fields:
    - field: id
      format: "des_{snake_case_name}"
      desc: "Design ID"
    - field: type
      format: "design"
      desc: "固定值，表示这是设计节点"
    - field: name
      format: "string"
      desc: "设计决策名称"
    - field: intent
      format: "string"
      desc: "这个设计决策要解决什么问题？"

  optional_fields:
    - field: domain
      format: "dom_{name}"
      desc: "所属 Domain (如果与特定领域相关)"
    - field: source_anchor
      format: "PRD.md#{anchor_id}"
      desc: "PRD 中的锚点引用"
    - field: rationale
      format: "multiline string"
      desc: "为什么做这个决策？设计的理由和思考过程"
    - field: principles
      format: "list[PrincipleObject]"
      desc: "从这个决策衍生的原则列表"
    - field: concepts
      format: "list[ConceptObject]"
      desc: "概念定义列表 (用于架构类设计)"
    - field: decisions
      format: "list[DecisionObject]"
      desc: "具体决策列表 (用于技术选型类设计)"
    - field: design_decisions
      format: "list[DesignDecisionObject]"
      desc: "设计决策列表 (用于 Schema 设计等)"
    - field: phases
      format: "list[PhaseObject]"
      desc: "阶段定义 (用于策略类设计)"
    - field: domains
      format: "list[DomainDescObject]"
      desc: "领域描述列表 (用于领域模型设计)"
    - field: classification
      format: "ClassificationObject"
      desc: "分类定义 (用于知识分类设计)"
    - field: constraints
      format: "list[string]"
      desc: "约束列表"

  # 原则对象结构
  principle_object_schema:
    structure:
      - field: name
        format: "string"
        desc: "原则名称"
      - field: desc
        format: "string"
        desc: "原则描述"
      - field: why
        format: "string"
        desc: "为什么有这个原则 (可选)"

  # 概念对象结构 (用于 des_architecture)
  concept_object_schema:
    structure:
      - field: level
        format: "string"
        desc: "层级 (L0/L1/L2)"
      - field: name
        format: "string"
        desc: "概念名称"
      - field: definition
        format: "string"
        desc: "概念定义"
      - field: why
        format: "string"
        desc: "为什么这样定义"
      - field: granularity
        format: "string"
        desc: "粒度标准"
      - field: examples
        format: "list[string]"
        desc: "示例列表"

  # 设计决策对象结构 (用于 des_specgraph_schema)
  design_decision_object_schema:
    structure:
      - field: decision
        format: "string"
        desc: "决策内容"
      - field: reason
        format: "multiline string"
        desc: "决策理由"
      - field: alternatives_considered
        format: "list[AlternativeObject]"
        desc: "考虑过的替代方案"
      - field: tradeoff
        format: "string"
        desc: "权衡说明 (可选)"

  examples:
    - id: "des_philosophy"
      content: "核心理念 - 为什么选择 Spec-First？为什么是 Serial Flow？"
    - id: "des_architecture"
      content: "分层架构 - 为什么分 L0/L1/L2？每层的目的是什么？"
    - id: "des_specgraph_schema"
      content: "数据库 Schema 设计决策 - 为什么用三表架构？为什么用 ID 前缀？"

# =============================================================================
# 5. 基质节点规范 (Substrate Node)
# =============================================================================
# Substrate 回答 "How & Constraints" - 执行约束和验证规则
substrate_schema:
  path_pattern: ".specgraph/substrate/sub_{snake_case_name}.yaml"
  purpose: |
    Substrate 节点定义执行约束，帮助 AI 在编码时遵循规范。
    AI 在以下场景加载 Substrate：
    - 编写代码时 (加载 sub_tech_stack, sub_coding_style)
    - 创建/验证 YAML 文件时 (加载 sub_meta_schema)
    - 审查代码合规性时

  required_fields:
    - field: id
      format: "sub_{snake_case_name}"
      desc: "Substrate ID"
    - field: type
      format: "substrate"
      desc: "固定值，表示这是基质节点"
    - field: name
      format: "string"
      desc: "基质名称"

  optional_fields:
    - field: description
      format: "string"
      desc: "基质描述"
    - field: source_anchor
      format: "PRD.md#{anchor_id}"
      desc: "PRD 中的锚点引用"
    - field: constraints
      format: "list[string]"
      desc: "具体的约束规则列表"
    - field: validation_rules
      format: "list[RuleObject]"
      desc: "验证规则 (用于自动化检查)"
    - field: environment
      format: "EnvironmentObject"
      desc: "环境配置 (用于 sub_tech_stack)"
    - field: core_libraries
      format: "dict[name: LibraryObject]"
      desc: "核心库配置 (用于 sub_tech_stack)"

  examples:
    - id: "sub_tech_stack"
      content: "技术栈约束 - 用 typer 不用 click，用 pathlib 不用 os.path"
    - id: "sub_coding_style"
      content: "编码规范 - 命名规则、Type Hints 要求、文件路径规范"
    - id: "sub_meta_schema"
      content: "YAML 结构规范 - 各类节点的必填字段、命名约定"
