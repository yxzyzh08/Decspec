# DevSpec：AI辅助软件开发规范与工具集

> **Product Requirements Document (PRD)**  
> Version 1.0 | 需求定稿

---

## 1. 产品定位

### 1.1 一句话定义

DevSpec 是一个 **串行会话式的智能结对编程环境**，帮助超级个体利用AI高效开发软件产品。

### 1.2 核心理念

```
❌ 不是：强制的、并行的、严苛的开发流水线
✅ 而是：串行的、会话式的、辅助记忆的智能结对编程环境
```

### 1.3 设计哲学

| 原则 | 说明 |
|------|------|
| **极速串行** | 放弃并行执念，利用AI速度一个任务做完再做下一个 |
| **会话隔离** | 任务内保持上下文，任务结束后清空回归无状态 |
| **测试即一致** | 测试用例作为硬通货，跑通即代表文档与代码一致 |
| **自动化优先** | 工具减轻管理负担，而非增加 |
| **引导非强制** | 警告+建议，而非阻止+惩罚 |

---

## 2. 目标用户

### 2.1 用户画像：超级个体

```
角色：独立开发者 / 技术创业者 / 全栈工程师
技能：产品设计 + 代码研发 + 测试，三位一体
工具：Claude Code / Codex / Gemini CLI 等AI编程工具
痛点：
  - AI无状态，每次都要重新解释项目背景
  - 项目复杂后，难以记住所有功能和依赖
  - 文档与代码容易脱节
  - 一个人管理太多东西，认知过载
```

### 2.2 核心诉求

| 诉求 | 权重 |
|------|------|
| 减少重复解释项目背景的时间 | ⭐⭐⭐⭐⭐ |
| 保持文档与代码的一致性 | ⭐⭐⭐⭐ |
| 降低项目管理的认知负荷 | ⭐⭐⭐⭐ |
| 快速切换不同项目/模块 | ⭐⭐⭐ |

---

## 3. AI能力边界（关键约束）

在设计系统前，必须明确当前AI的真实能力边界：

### 3.1 AI擅长的

| 能力 | 可靠度 | 应用场景 |
|------|--------|----------|
| 单文件代码生成 | ⭐⭐⭐⭐⭐ | 新功能实现 |
| 代码补全和修改 | ⭐⭐⭐⭐⭐ | 日常开发 |
| 文档生成 | ⭐⭐⭐⭐ | PRD/设计文档草稿 |
| 测试用例生成 | ⭐⭐⭐⭐ | 单元测试 |
| 代码解释 | ⭐⭐⭐⭐ | 代码Review辅助 |

### 3.2 AI不擅长的

| 能力 | 可靠度 | 应对策略 |
|------|--------|----------|
| 复杂跨文件重构 | ⭐⭐ | 人工拆解为小任务 |
| 全局架构决策 | ⭐⭐ | 人工决策，AI执行 |
| 自我纠错 | ⭐⭐ | 多模型审计 |
| 长期记忆 | ⭐ | 外部知识图谱 |
| 判断业务正确性 | ⭐ | 测试用例验证 |

### 3.3 关键约束：自我纠错的盲点

```
问题：AI在"自我纠错"时容易陷入"好好好，我改"但实际没改对的怪圈

解决方案：引入"第三方"审计机制
  - 方案A：Model A 写代码，Model B 做审计
  - 方案B：强制编写自动化测试，用测试结果作为客观标准
  - 方案C：人工Review关键变更
```

---

## 4. 核心功能需求

### 4.1 功能总览

```
DevSpec 系统
├── F1: 知识图谱（SpecIndex）      ← 数据基座
├── F2: 需求池（Backlog）          ← 需求管理
├── F3: 任务会话（Task Session）   ← 开发执行
├── F4: 上下文构建（Context）      ← AI辅助
├── F5: 一致性校验（Audit）        ← 质量保证
└── F6: 自动化维护（Auto-Sync）    ← 降低负担
```

---

### F1: 知识图谱（SpecIndex）

#### 目标
为AI提供"外部长期记忆"，存储软件产品的功能、接口、依赖关系。

#### 核心能力

| 能力 | 说明 |
|------|------|
| 结构化存储 | Feature/API/Component/DataModel/Function |
| 依赖管理 | 节点之间的依赖关系（HARD/SOFT） |
| 快速查询 | 属性查询 + 全文搜索 + 图遍历 |
| 版本同步 | 跟随Git分支，切换分支时自动同步 |

#### 分层自动化策略

| 层级 | 维护方式 | 人工介入 |
|------|----------|----------|
| **L3 实现层** | 100%自动扫描（Tree-sitter） | 无需 |
| **L2 接口层** | 80%自动提取，修改Public API时触发审核 | 审核确认 |
| **L1 概念层** | AI建议，人工定义 | 主导 |
| **基质层** | 人工定义，全局只读 | 主导 |

#### 非目标
- ❌ 不存储完整代码（只存摘要）
- ❌ 不做任务管理（由F2负责）
- ❌ 不做流程控制（由F3负责）

---

### F2: 需求池（Backlog）

#### 目标
解决"工作量门槛"问题，用需求批处理替代任务暂停。

#### 核心理念

```
❌ 原方案：挂起代码任务，等工作量够了再执行
   问题：挂起的任务可能因代码结构变化而失效

✅ 新方案：暂存需求（Spec），而非代码任务
   好处：需求不会过期，可以灵活打包
```

#### 核心能力

| 能力 | 说明 |
|------|------|
| 需求收集 | 随时添加：改颜色、加日志、换图标... |
| 智能打包 | 开始大任务时，自动提示相关的小需求 |
| 需求分类 | 按模块/功能/优先级分类 |
| 需求状态 | draft → ready → in_progress → done |

#### 工作流

```
日常：
  用户随时往需求池扔想法
  "改登录按钮颜色" → 需求池
  "加个日志" → 需求池
  "修复那个bug" → 需求池

启动任务时：
  用户："我要开发登录功能"
  系统扫描需求池，提示：
  "您还有3个关于登录的小需求，要不要一起打包？"
  用户确认后，一次Session解决多个问题
```

#### 紧急需求处理

```
场景：发现紧急bug/安全漏洞
处理：允许跳过打包，直接启动任务
标记：记录为"紧急任务"，事后统计分析
```

---

### F3: 任务会话（Task Session）

#### 目标
解决"无状态AI"的上下文重建成本问题。

#### 核心理念

```
❌ 原方案：每句话都清空上下文
   问题：Token消耗巨大，缺乏连贯性

✅ 新方案：任务级沙箱
   - 任务内：保持上下文
   - 任务结束：清空，回归无状态
```

#### 会话生命周期

```
┌─────────────────────────────────────────────────────────┐
│  Phase 1: Start Session                                 │
│  ─────────────────────────────────────────────────────  │
│  • 加载任务相关的知识图谱上下文                          │
│  • 加载关联文档摘要                                      │
│  • 加载基质规范（日志/安全/错误码）                      │
│  • 注入需求池中打包的需求                                │
└─────────────────────────────────────────────────────────┘
                          ▼
┌─────────────────────────────────────────────────────────┐
│  Phase 2: Developing（核心阶段）                         │
│  ─────────────────────────────────────────────────────  │
│  • AI在此会话内多轮对话                                  │
│  • 上下文保留，支持Chain of Thought                     │
│  • 可随时查询知识图谱获取更多信息                        │
│  • 代码变更实时暂存                                      │
└─────────────────────────────────────────────────────────┘
                          ▼
┌─────────────────────────────────────────────────────────┐
│  Phase 3: Review & Test                                 │
│  ─────────────────────────────────────────────────────  │
│  • 运行自动化测试                                        │
│  • 一致性校验（F5）                                      │
│  • 人工Review（可选）                                    │
└─────────────────────────────────────────────────────────┘
                          ▼
┌─────────────────────────────────────────────────────────┐
│  Phase 4: Commit & Close                                │
│  ─────────────────────────────────────────────────────  │
│  • 代码提交到Git                                         │
│  • 触发知识图谱自动更新（F6）                            │
│  • 会话销毁，上下文清空                                  │
│  • 需求池中相关需求标记完成                              │
└─────────────────────────────────────────────────────────┘
```

#### 会话隔离原则

```
✅ 允许：
  - 会话内多轮对话
  - 会话内累积代码变更
  - 会话内查询知识图谱

❌ 禁止：
  - 跨会话共享上下文
  - 会话未提交就切换到其他任务
  - 长时间挂起会话（超时自动关闭）
```

---

### F4: 上下文构建（Context Builder）

#### 目标
根据任务智能构建AI所需的最小且充分的上下文。

#### 核心概念：关注气泡（Focus Bubble）

```
不是把整个项目扔给AI
而是构建一个"气泡"，只包含当前任务需要的信息

气泡内容：
├── 目标节点：当前要开发/修改的功能
├── 依赖节点：目标节点依赖的接口（只含签名，不含实现）
├── 被依赖节点：谁依赖了目标节点（影响分析）
├── 基质规范：相关的全局规范（日志/安全）
├── 关联文档：PRD/设计文档摘要
└── 打包需求：需求池中一起处理的小需求
```

#### Token预算控制

```
策略：分层压缩
├── L1 概念：完整保留（量小）
├── L2 接口：签名+摘要（压缩实现细节）
├── L3 函数：只保留被直接调用的（按需加载）
└── 文档：只保留摘要（需要时再查询全文）

目标：将上下文控制在8K-16K tokens
```

---

### F5: 一致性校验（Audit）

#### 目标
确保代码与文档/设计的一致性。

#### 核心理念：测试驱动一致性（TDD over Doc-Check）

```
❌ 原方案：纯文本比对（文档 vs 代码）
   问题：语义一致性难以自动判断，容易死循环

✅ 新方案：测试用例作为硬通货
   - AI必须先写/更新测试用例
   - 测试跑通 = 一致
   - 文本比对只作为辅助
```

#### 校验层次

| 层次 | 校验方式 | 自动化程度 |
|------|----------|------------|
| **结构一致性** | API路径/参数/返回值匹配 | 100%自动 |
| **行为一致性** | 测试用例通过 | 100%自动 |
| **语义一致性** | 文档描述vs代码逻辑 | 辅助提示，人工确认 |

#### 校验流程

```
代码变更后：
1. 运行自动化测试
   ├── 通过 → 继续
   └── 失败 → 阻止提交，返回修复

2. 结构一致性检查
   ├── API签名是否与文档匹配
   ├── 依赖关系是否已声明
   └── 违规 → 警告，建议修复

3. 语义一致性提示（可选）
   ├── AI辅助比对文档和代码
   └── 发现疑似不一致 → 提示人工确认
```

#### 多模型审计

```
解决AI自我纠错盲点：

方案A：双模型审计
  - Model A (如Claude)：写代码
  - Model B (如GPT-4)：审计代码
  - 不同模型的盲点不同，交叉审计更可靠

方案B：测试驱动
  - AI写代码 + AI写测试
  - 用测试结果（客观事实）替代语义判断（主观）
  
推荐：优先使用方案B，关键场景叠加方案A
```

---

### F6: 自动化维护（Auto-Sync）

#### 目标
降低知识图谱的维护负担，避免用户变成"图谱管理员"。

#### 核心理念

```
❌ 原方案：AI每次改代码都手动申请更新图谱
   问题：管理成本高，用户会因麻烦而跳过，最终图谱脱节

✅ 新方案：代码即真理，文档即索引
   - L3自动扫描，无需人工
   - L2变更时触发审核
   - L1人工维护（量少）
```

#### 自动化策略

| 层级 | 触发条件 | 处理方式 | 人工介入 |
|------|----------|----------|----------|
| **L3** | 代码文件变更 | 自动扫描，更新函数签名 | 无 |
| **L2** | Public API变更 | 检测变更，生成Diff，请求确认 | 确认 |
| **L1** | 新功能上线 | 提示用户更新Feature定义 | 主导 |

#### 触发时机

```
实时（Watch模式）：
  - 代码保存时自动扫描L3

提交时（Commit Hook）：
  - 检测L2变更，提示确认
  - 运行一致性校验

定期（可选）：
  - 全量扫描，检测遗漏
  - 生成健康报告
```

---

## 5. 文档管理策略

### 5.1 文档分级

不是所有项目都需要完整文档，根据项目类型选择：

| 项目类型 | 文档要求 | 说明 |
|----------|----------|------|
| **核心项目** | 完整文档 | PRD + 设计文档 + 测试用例 |
| **常规项目** | 标准文档 | 简化PRD + 接口文档 |
| **实验项目** | 轻量文档 | 只需intent + contract |
| **紧急修复** | 事后补全 | 先修复，限时补文档 |

### 5.2 文档先行策略

```
大修改（新功能/架构变更）：
  ✅ 文档先行：先更新设计，再写代码
  
小修改（bug修复/微调）：
  ⚠️ 允许后补：先改代码，限时补文档（如24小时内）
  
紧急修复（安全漏洞/线上故障）：
  🚨 跳过文档：先修复，事后补全并Review
```

---

## 6. 系统边界

### 6.1 系统包含（IN SCOPE）

```
✅ 知识图谱存储与查询
✅ 需求池管理
✅ 任务会话管理
✅ 上下文自动构建
✅ 一致性校验（测试驱动）
✅ 自动化代码扫描
✅ CLI工具
```

### 6.2 系统不包含（OUT OF SCOPE）

```
❌ AI模型本身（使用外部AI工具）
❌ IDE插件（首期不做）
❌ 图形化界面（CLI优先）
❌ 团队协作功能（单人使用）
❌ CI/CD集成（首期不做）
```

---

## 7. 技术约束

### 7.1 技术选型

| 组件 | 技术 | 理由 |
|------|------|------|
| 语言 | Python 3.11+ | AI生态丰富 |
| 存储 | YAML + SQLite | 双模态架构 |
| 代码扫描 | Tree-sitter | 多语言支持 |
| 图计算 | NetworkX | 轻量级 |
| API | FastAPI | 现代化 |
| CLI | Typer | 易用 |

### 7.2 性能要求

| 指标 | 要求 |
|------|------|
| 上下文构建 | < 1秒 |
| 全量扫描（1000文件） | < 30秒 |
| 增量扫描 | < 2秒 |
| 查询响应 | < 100ms |

---

## 8. 模块划分

基于以上需求，系统拆解为以下模块：

```
┌─────────────────────────────────────────────────────────────┐
│                      DevSpec 系统架构                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐      │
│   │ M1: 知识    │   │ M2: 需求池  │   │ M3: 会话    │      │
│   │ 图谱        │   │ (Backlog)   │   │ 管理        │      │
│   │ (SpecIndex) │   │             │   │ (Session)   │      │
│   └──────┬──────┘   └──────┬──────┘   └──────┬──────┘      │
│          │                 │                 │              │
│          └─────────────────┼─────────────────┘              │
│                            │                                │
│                            ▼                                │
│   ┌─────────────────────────────────────────────────────┐  │
│   │           M4: 上下文构建 (Context Builder)           │  │
│   └─────────────────────────────────────────────────────┘  │
│                            │                                │
│                            ▼                                │
│   ┌─────────────────────────────────────────────────────┐  │
│   │           M5: 一致性校验 (Audit)                     │  │
│   └─────────────────────────────────────────────────────┘  │
│                            │                                │
│                            ▼                                │
│   ┌─────────────────────────────────────────────────────┐  │
│   │           M6: AI适配层 (AI Adapter)                  │  │
│   │           (Claude Code / Codex / Gemini CLI)        │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 模块优先级

| 优先级 | 模块 | 理由 |
|--------|------|------|
| P0 | M1: 知识图谱 | 数据基座，其他模块依赖 |
| P0 | M4: 上下文构建 | 核心价值，解决AI无状态问题 |
| P1 | M5: 一致性校验 | 质量保证 |
| P1 | M3: 会话管理 | 用户体验 |
| P2 | M2: 需求池 | 效率优化 |
| P2 | M6: AI适配层 | 集成层 |

---

## 9. MVP范围

### 9.1 MVP必须有

```
✅ M1: 知识图谱基础功能
   - 节点CRUD
   - 依赖查询
   - 自动扫描L3

✅ M4: 上下文构建
   - 关注气泡生成
   - Token预算控制

✅ M5: 基础校验
   - 结构一致性检查
   - 测试运行集成

✅ CLI工具
   - 初始化项目
   - 启动/结束会话
   - 查询知识图谱
```

### 9.2 MVP不包含

```
❌ M2: 需求池（V2）
❌ M3: 完整会话管理（V2）
❌ M6: 多AI适配（V2）
❌ 多模型审计（V2）
❌ IDE插件（V3）
❌ Web界面（V3）
```

---

## 10. 成功指标

| 指标 | 目标 | 衡量方式 |
|------|------|----------|
| 上下文构建时间 | 减少80% | 对比手动整理上下文的时间 |
| 文档代码一致性 | 提升到90% | 抽样检查 |
| 知识图谱维护时间 | < 10分钟/天 | 用户反馈 |
| AI任务成功率 | 提升30% | 对比无工具时的成功率 |

---

## 附录A：术语表

| 术语 | 定义 |
|------|------|
| **超级个体** | 具备产品+研发+测试能力的独立开发者 |
| **知识图谱** | 结构化存储软件功能、接口、依赖的系统 |
| **关注气泡** | 根据任务构建的最小且充分的上下文 |
| **任务会话** | 一个完整的开发任务周期，内部保持上下文 |
| **需求池** | 暂存待处理需求的列表 |
| **基质层** | 全局规范（日志/安全/错误码） |
| **TDD一致性** | 用测试通过作为文档代码一致的标准 |

---

## 附录B：与原始需求的对照

| 原始需求 | 优化后 | 理由 |
|----------|--------|------|
| 强制规范 | 引导+警告 | 避免用户放弃使用 |
| 并行开发 | 极速串行 | 人类是单线程的 |
| 每次清空上下文 | 任务会话制 | 减少Token消耗 |
| 工作量门槛暂停任务 | 需求池+智能打包 | 避免挂起任务失效 |
| 文档循环校验 | 测试驱动一致性 | 避免死循环 |
| 强制更新图谱 | 分层自动化 | 降低维护负担 |

---

*Document Version: 1.0*
*Status: 需求定稿*
